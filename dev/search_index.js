var documenterSearchIndex = {"docs":
[{"location":"api/#Detailed-API","page":"Index","title":"Detailed API","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"simulation/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"simulation/#Background","page":"Simulations","title":"Background","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"We provide a shorthand function for running simulations of Control Affine Systems equipped with feedback controllers:","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"sol = simulate(Σ, k, x0, T)","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"where Σ is a ControlAffineSystem, k is a feedback controller of the form k(x,t) or k(x), x0 is the initial state, and T is the length of the simulation. This function simply calls a solver from DifferentialEquations.jl to simulate the closed-loop system and returns an ODE solution object.","category":"page"},{"location":"simulation/#Implementation","page":"Simulations","title":"Implementation","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"simulate(Σ::ControlAffineSystem, x0, T::Float64)\nsimulate(Σ::ControlAffineSystem, k::Function, x0, T::Float64)","category":"page"},{"location":"simulation/#ControlBarrierFunctions.simulate-Tuple{ControlAffineSystem, Any, Float64}","page":"Simulations","title":"ControlBarrierFunctions.simulate","text":"simulate(Σ::ControlAffineSystem, x0, T::Float64)\n\nSimulate a control affine system from initial condition x0 for T seconds.\n\n\n\n\n\n","category":"method"},{"location":"simulation/#ControlBarrierFunctions.simulate-Tuple{ControlAffineSystem, Function, Any, Float64}","page":"Simulations","title":"ControlBarrierFunctions.simulate","text":"simulate(Σ::ControlAffineSystem, k::Function, x0, T::Float64)\n\nSimulate a closed-loop control affine system from initial condition x0 for T seconds. \n\n\n\n\n\n","category":"method"},{"location":"systems/#System-Definitions","page":"Systems","title":"System Definitions","text":"","category":"section"},{"location":"systems/#Background","page":"Systems","title":"Background","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"The starting point for most the utilities in this package is the ControlAffineSystem type. This type represents a nonlinear control affine system described by:","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"dotx = f(x) + g(x)u","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"where xinmathbbR^n is the system state, uinmathbbR^n is the control input, fmathbbR^nrightarrowmathbbR^n is a vector field characterizing the drift dynamics, and gmathbbR^nrightarrowmathbbR^ntimes m is a matrix whose columns capture the control directions. A control affine system can be constructed with:","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"Σ = ControlAffineSystem(name, n, m, f, g)","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"where name::String is a string describing the system, n::Int is an integer denoting the state dimension, m::Int is an integer denoting the control dimension, and f::Function and g::Function are functions of the form f(x) and g(x) which take as input an n-dimensional vector x or a scalar if n=1. Alternatively, if you do not want to assign a name to system you can use:","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"Σ = ControlAffineSystem(n, m, f, g)","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"to construct a system without a name. ","category":"page"},{"location":"systems/#Implementation","page":"Systems","title":"Implementation","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"ControlAffineSystem\nControlAffineSystem(n::Int, m::Int, f::Function, g::Function)","category":"page"},{"location":"systems/#ControlBarrierFunctions.ControlAffineSystem","page":"Systems","title":"ControlBarrierFunctions.ControlAffineSystem","text":"ControlAffineSystem\n\nControl affine system described by the dynamics x = f(x) + g(x)u where x  ℝⁿ is the system state, u  ℝᵐ is the control input and f  ℝⁿ  ℝⁿ and g  ℝⁿ  ℝⁿˣᵐ represent the dynamics.\n\nFields\n\nname::String : name of system, e.g., \"double integrator\", \"unicycle\", \"quadrotor\", etc.\nn::Int : state dimension\nm::Int : control dimension\nf::Function : drift dynamics\ng::Function : control directions\n\n\n\n\n\n","category":"type"},{"location":"systems/#ControlBarrierFunctions.ControlAffineSystem-Tuple{Int64, Int64, Function, Function}","page":"Systems","title":"ControlBarrierFunctions.ControlAffineSystem","text":"ControlAffineSystem(n::Int, m::Int, f::Function, g::Function)\n\nConstruct a control affine system. Name defaults to missing if not provided.\n\n\n\n\n\n","category":"method"},{"location":"barriers/#Control-Barrier-Functions","page":"Barrier Functions","title":"Control Barrier Functions","text":"","category":"section"},{"location":"barriers/#Background","page":"Barrier Functions","title":"Background","text":"","category":"section"},{"location":"barriers/#Implementation","page":"Barrier Functions","title":"Implementation","text":"","category":"section"},{"location":"barriers/","page":"Barrier Functions","title":"Barrier Functions","text":"ControlBarrierFunction\nControlBarrierFunction(h::Function, Σ::ControlAffineSystem, α::Function)\nControlBarrierFunction(h::Function, Σ::ControlAffineSystem)","category":"page"},{"location":"barriers/#ControlBarrierFunctions.ControlBarrierFunction","page":"Barrier Functions","title":"ControlBarrierFunctions.ControlBarrierFunction","text":"ControlBarrierFunction\n\nControl barrier function (CBF) defining a safe set as its zero superlevel set.\n\nFields\n\nh::Function : function defining the safe set h(x) ≥ 0\nα::Function : extended class K function a(h(x)) for CBF\n∇h::Function : gradient of CBF\nLfh::Function : Lie derivative of CBF along drift vector field f\nLgh::Function : Lie derivative of CBF along control directions g\n\n\n\n\n\n","category":"type"},{"location":"barriers/#ControlBarrierFunctions.ControlBarrierFunction-Tuple{Function, ControlAffineSystem, Function}","page":"Barrier Functions","title":"ControlBarrierFunctions.ControlBarrierFunction","text":"ControlBarrierFunction(h::Function, Σ::ControlAffineSystem, α::Function)\n\nConstruct a CBF from a function h, a control affine system Σ, and an extended class K function α.\n\n\n\n\n\n","category":"method"},{"location":"barriers/#ControlBarrierFunctions.ControlBarrierFunction-Tuple{Function, ControlAffineSystem}","page":"Barrier Functions","title":"ControlBarrierFunctions.ControlBarrierFunction","text":"ControlBarrierFunction(h::Function, Σ::ControlAffineSystem)\n\nIf no extended class K function provided, default to the identify function.\n\n\n\n\n\n","category":"method"},{"location":"#ControlBarrierFunctions.jl","page":"Home","title":"ControlBarrierFunctions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for implementing control barrier functions (CBFs) in Julia.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This toolbox provides utilities to construct nonlinear systems and control policies based on control barrier functions (CBFs). The objective here is to provide lightweight utilities for defining CBFs and various controllers that may be used within other research projects.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To download this package open the Julia REPL, enter the package manager (type ] into the REPL) and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"add ControlBarrierFunctions","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Load in packages\nusing ControlBarrierFunctions\nusing LinearAlgebra\nusing Plots\n\n# Create a single integrator\nn = 2\nm = 2\nf(x) = zeros(2)\ng(x) = diagm(ones(2))\nΣ = ControlAffineSystem(\"single integrator\", n, m, f, g)\n\n# Create a CBF for an obstacle\nxo = [-1.0, 1.0]\nro = 0.4\nh(x) = norm(x - xo)^2 - ro^2\nα(r) = r\ncbf = ControlBarrierFunction(h, Σ, α);\n\n# Nominal controller\nkd(x) = -x\n\n# Create a safety filter\nk = ExplicitSafetyFilter(cbf, Σ, kd);\n\n# Run a simulation\nx0 = [-2.1, 2.0]\nT = 15.0\nsol = simulate(Σ, k, x0, T)\n\n# Set up plots\ndefault(fontfamily=\"Computer Modern\", palette=:tab10, framestyle=:box, grid=false, lw=2)\n\n# Plot trajectory\nplot(sol, idxs=(1,2), label=\"\")\ncontour!(-1.5:0.01:-0.5, 0.5:0.01:1.5, (x,y) -> h([x,y]), levels=[0.0], colorbar=false, c=\"black\")","category":"page"},{"location":"controllers/#Controllers","page":"Controllers","title":"Controllers","text":"","category":"section"},{"location":"controllers/#Background","page":"Controllers","title":"Background","text":"","category":"section"},{"location":"controllers/#Quadratic-Programming-Safety-Filters","page":"Controllers","title":"Quadratic Programming Safety Filters","text":"","category":"section"},{"location":"controllers/","page":"Controllers","title":"Controllers","text":"ExplicitSafetyFilter\nExplicitSafetyFilter(cbf::ControlBarrierFunction, Σ::ControlAffineSystem, kd::Function)\nExplicitSafetyFilter(cbf::ControlBarrierFunction, Σ::ControlAffineSystem)\nQPSafetyFilter\nQPSafetyFilter(cbf::ControlBarrierFunction, Σ::ControlAffineSystem, kd::Function)\nQPSafetyFilter(cbfs::Vector{ControlBarrierFunction}, Σ::ControlAffineSystem, kd::Function)\nTunableQPSafetyFilter","category":"page"},{"location":"controllers/#ControlBarrierFunctions.ExplicitSafetyFilter","page":"Controllers","title":"ControlBarrierFunctions.ExplicitSafetyFilter","text":"ExplicitSafetyFilter <: SafetyFilter\n\nController that uses the closed-form solution to a control barrier function quadratic program.\n\nFields\n\nk::Function : function that computes safe control actions\n\n\n\n\n\n","category":"type"},{"location":"controllers/#ControlBarrierFunctions.ExplicitSafetyFilter-Tuple{ControlBarrierFunction, ControlAffineSystem, Function}","page":"Controllers","title":"ControlBarrierFunctions.ExplicitSafetyFilter","text":"ExplicitSafetyFilter(cbf::ControlBarrierFunction, Σ::ControlAffineSystem, kd::Function)\n\nConstruct an ExplicitSafetyFilter from a cbf and a desired controller.\n\n\n\n\n\n","category":"method"},{"location":"controllers/#ControlBarrierFunctions.ExplicitSafetyFilter-Tuple{ControlBarrierFunction, ControlAffineSystem}","page":"Controllers","title":"ControlBarrierFunctions.ExplicitSafetyFilter","text":"ExplicitSafetyFilter(cbf::ControlBarrierFunction, Σ::ControlAffineSystem)\n\nIf no desired controller passed in then default it to zero.\n\n\n\n\n\n","category":"method"},{"location":"controllers/#ControlBarrierFunctions.QPSafetyFilter","page":"Controllers","title":"ControlBarrierFunctions.QPSafetyFilter","text":"QPSafetyFilter <: SafetyFilter\n\nController that solves a control barrier function-based quadratic program (CBF-QP).\n\nUses OSQP to solve the corresponding QP.\n\nFields\n\nk::Function : function that computes safe control actions\n\n\n\n\n\n","category":"type"},{"location":"controllers/#ControlBarrierFunctions.QPSafetyFilter-Tuple{ControlBarrierFunction, ControlAffineSystem, Function}","page":"Controllers","title":"ControlBarrierFunctions.QPSafetyFilter","text":"QPSafetyFilter(cbf::ControlBarrierFunction, Σ::ControlAffineSystem, kd::Function)\nQPSafetyFilter(cbf::ControlBarrierFunction, Σ::ControlAffineSystem, kd::Function, umin, umax)\n\nAdd ability to pass in single CBF.\n\n\n\n\n\n","category":"method"},{"location":"controllers/#ControlBarrierFunctions.QPSafetyFilter-Tuple{Vector{ControlBarrierFunction}, ControlAffineSystem, Function}","page":"Controllers","title":"ControlBarrierFunctions.QPSafetyFilter","text":"QPSafetyFilter(cbfs::Vector{ControlBarrierFunction}, Σ::ControlAffineSystem, kd::Function)\n\nConstruct an QPSafetyFilter from a cbf and a desired controller.\n\n\n\n\n\n","category":"method"},{"location":"controllers/#ControlBarrierFunctions.TunableQPSafetyFilter","page":"Controllers","title":"ControlBarrierFunctions.TunableQPSafetyFilter","text":"TunableQPSafetyFilter <: SafetyFilter\n\nController that solves a control barrier function-based quadratic program (CBF-QP) with tunable class K functions.\n\nUses OSQP to solve the corresponding QP.\n\nFields\n\nk::Function : function that computes safe control actions\n\n\n\n\n\n","category":"type"},{"location":"controllers/#Smooth-Safety-Filters","page":"Controllers","title":"Smooth Safety Filters","text":"","category":"section"},{"location":"controllers/","page":"Controllers","title":"Controllers","text":"SmoothSafetyFilter\nISSfSmoothSafetyFilter","category":"page"},{"location":"controllers/#ControlBarrierFunctions.SmoothSafetyFilter","page":"Controllers","title":"ControlBarrierFunctions.SmoothSafetyFilter","text":"SmoothSafetyFilter <: SafetyFilter\n\nSmooth controller that approximates CBF-QP arbitrarily closely.\n\nFields\n\nformula::String : string indicating formula used in smooth safety filter\nσ::Float64 : smoothing parameter\nk::Function : function that computes safe control actions\n\n\n\n\n\n","category":"type"},{"location":"controllers/#ControlBarrierFunctions.ISSfSmoothSafetyFilter","page":"Controllers","title":"ControlBarrierFunctions.ISSfSmoothSafetyFilter","text":"ISSfSmoothSafetyFilter <: SafetyFilter\n\nSmooth controller that approximates an input-to-state safe (ISSf) CBF-QP arbitrarily closely.\n\nFields\n\nformula::String : string indicating formula used in smooth safety filter\nσ::Float64 : smoothing parameter\nk::Function : function that computes safe control actions\nε::Float64 : Issf robustness parameter for matched uncertainties\n\n\n\n\n\n","category":"type"}]
}
