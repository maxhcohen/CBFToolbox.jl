var documenterSearchIndex = {"docs":
[{"location":"api/#Detailed-API","page":"Index","title":"Detailed API","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"systems/#System-Definitions","page":"Systems","title":"System Definitions","text":"","category":"section"},{"location":"systems/#Background","page":"Systems","title":"Background","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"The starting point for most the utilities in this package is the ControlAffineSystem type. This type represents a nonlinear control affine system described by:","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"dotx = f(x) + g(x)u","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"where xinmathbbR^n is the system state, uinmathbbR^n is the control input, fmathbbR^nrightarrowmathbbR^n is a vector field characterizing the drift dynamics, and gmathbbR^nrightarrowmathbbR^ntimes m is a matrix whose columns capture the control directions. A control affine system can be constructed with:","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"Σ = ControlAffineSystem(name, n, m, f, g)","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"where name::String is a string describing the system, n::Int is an integer denoting the state dimension, m::Int is an integer denoting the control dimension, and f::Function and g::Function are functions of the form f(x) and g(x) which take as input an n-dimensional vector x or a scalar if n=1. Alternatively, if you do not want to assign a name to system you can use:","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"Σ = ControlAffineSystem(n, m, f, g)","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"to construct a system without a name. ","category":"page"},{"location":"systems/#Implementation","page":"Systems","title":"Implementation","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"ControlAffineSystem\nControlAffineSystem(n::Int, m::Int, f::Function, g::Function)","category":"page"},{"location":"systems/#CBFToolbox.ControlAffineSystem","page":"Systems","title":"CBFToolbox.ControlAffineSystem","text":"ControlAffineSystem\n\nControl affine system described by the dynamics x = f(x) + g(x)u where x  ℝⁿ is the system state, u  ℝᵐ is the control input and f  ℝⁿ  ℝⁿ and g  ℝⁿ  ℝⁿˣᵐ represent the dynamics.\n\nFields\n\nname::String : name of system, e.g., \"double integrator\", \"unicycle\", \"quadrotor\", etc.\nn::Int : state dimension\nm::Int : control dimension\nf::Function : drift dynamics\ng::Function : control directions\n\n\n\n\n\n","category":"type"},{"location":"systems/#CBFToolbox.ControlAffineSystem-Tuple{Int64, Int64, Function, Function}","page":"Systems","title":"CBFToolbox.ControlAffineSystem","text":"ControlAffineSystem(n::Int, m::Int, f::Function, g::Function)\n\nConstruct a control affine system. Name defaults to missing if not provided.\n\n\n\n\n\n","category":"method"},{"location":"barriers/#Control-Barrier-Functions","page":"Barrier Functions","title":"Control Barrier Functions","text":"","category":"section"},{"location":"barriers/#Background","page":"Barrier Functions","title":"Background","text":"","category":"section"},{"location":"barriers/#Implementation","page":"Barrier Functions","title":"Implementation","text":"","category":"section"},{"location":"barriers/","page":"Barrier Functions","title":"Barrier Functions","text":"ControlBarrierFunction","category":"page"},{"location":"barriers/#CBFToolbox.ControlBarrierFunction","page":"Barrier Functions","title":"CBFToolbox.ControlBarrierFunction","text":"ControlBarrierFunction\n\nControl barrier function (CBF) defining a safe set as its zero superlevel set.\n\nFields\n\nh::Function : function defining the safe set h(x) ≥ 0\nα::Function : extended class K function a(h(x)) for CBF\n∇h::Function : gradient of CBF\nLfh::Function : Lie derivative of CBF along drift vector field f\nLgh::Function : Lie derivative of CBF along control directions g\n\n\n\n\n\n","category":"type"},{"location":"#CBFToolbox.jl","page":"Home","title":"CBFToolbox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for implementing control barrier functions (CBFs) in Julia.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This toolbox provides utilities to construct nonlinear systems and control policies based on control barrier functions (CBFs). The objective here is to provide lightweight utilities for defining CBFs and various controllers that may be used within other research projects.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To download this package open the Julia REPL, enter the package manager (type ] into the REPL) and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/maxhcohen/CBFToolbox.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Load in packages\nusing CBFToolbox\nusing LinearAlgebra\nusing Plots\n\n# Create a single integrator\nn = 2\nm = 2\nf(x) = zeros(2)\ng(x) = diagm(ones(2))\nΣ = ControlAffineSystem(\"single integrator\", n, m, f, g)\n\n# Create a CBF for an obstacle\nxo = [-1.0, 1.0]\nro = 0.4\nh(x) = norm(x - xo)^2 - ro^2\nα(r) = r\ncbf = ControlBarrierFunction(h, Σ, α);\n\n# Nominal controller\nkd(x) = -x\n\n# Create a safety filter\nk = ExplicitSafetyFilter(cbf, Σ, kd);\n\n# Run a simulation\nx0 = [-2.1, 2.0]\nT = 15.0\nsol = simulate(Σ, k, x0, T)\n\n# Set up plots\ndefault(fontfamily=\"Computer Modern\", palette=:tab10, framestyle=:box, grid=false, lw=2)\n\n# Plot trajectory\nplot(sol, idxs=(1,2), label=\"\")\ncontour!(-1.5:0.01:-0.5, 0.5:0.01:1.5, (x,y) -> h([x,y]), levels=[0.0], colorbar=false, c=\"black\")","category":"page"},{"location":"controllers/#Controllers","page":"Controllers","title":"Controllers","text":"","category":"section"},{"location":"controllers/#Background","page":"Controllers","title":"Background","text":"","category":"section"},{"location":"controllers/#Quadratic-Programming-Safety-Filters","page":"Controllers","title":"Quadratic Programming Safety Filters","text":"","category":"section"},{"location":"controllers/","page":"Controllers","title":"Controllers","text":"ExplicitSafetyFilter\nQPSafetyFilter\nTunableQPSafetyFilter","category":"page"},{"location":"controllers/#CBFToolbox.ExplicitSafetyFilter","page":"Controllers","title":"CBFToolbox.ExplicitSafetyFilter","text":"ExplicitSafetyFilter <: SafetyFilter\n\nController that uses the closed-form solution to a control barrier function quadratic program.\n\nFields\n\nk::Function : function that computes safe control actions\n\n\n\n\n\n","category":"type"},{"location":"controllers/#CBFToolbox.QPSafetyFilter","page":"Controllers","title":"CBFToolbox.QPSafetyFilter","text":"QPSafetyFilter <: SafetyFilter\n\nController that solves a control barrier function-based quadratic program (CBF-QP).\n\nUses OSQP to solve the corresponding QP.\n\nFields\n\nk::Function : function that computes safe control actions\n\n\n\n\n\n","category":"type"},{"location":"controllers/#CBFToolbox.TunableQPSafetyFilter","page":"Controllers","title":"CBFToolbox.TunableQPSafetyFilter","text":"TunableQPSafetyFilter <: SafetyFilter\n\nController that solves a control barrier function-based quadratic program (CBF-QP) with tunable class K functions.\n\nUses OSQP to solve the corresponding QP.\n\nFields\n\nk::Function : function that computes safe control actions\n\n\n\n\n\n","category":"type"},{"location":"controllers/#Smooth-Safety-Filters","page":"Controllers","title":"Smooth Safety Filters","text":"","category":"section"},{"location":"controllers/","page":"Controllers","title":"Controllers","text":"SmoothSafetyFilter","category":"page"},{"location":"controllers/#CBFToolbox.SmoothSafetyFilter","page":"Controllers","title":"CBFToolbox.SmoothSafetyFilter","text":"SmoothSafetyFilter <: SafetyFilter\n\nSmooth controller that approximates CBF-QP arbitrarily closely.\n\nFields\n\nformula::String : string indicating formula used in smooth safety filter\nσ::Float64 : smoothing parameter\nk::Function : function that computes safe control actions\n\n\n\n\n\n","category":"type"},{"location":"controllers/#Robust-Safety-Filters","page":"Controllers","title":"Robust Safety Filters","text":"","category":"section"},{"location":"controllers/#Implementation","page":"Controllers","title":"Implementation","text":"","category":"section"}]
}
